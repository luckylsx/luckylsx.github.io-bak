---
layout: post
title: 索引为何使用B+树
category: MYSQL
---

## 问题思考

数据库索引的数据结构有很多种，比如：哈希索引、平衡二叉树索引、B树索引、B+树索引等等。

目前最流行的是B+树索引，那大家有没有想过为什么是B+树索引最流行，为什么其他索引应用不广泛

## 哈希索引

hash大家应该非常的熟悉，就是我们老生常谈的HashMap里用到的技术。Hash索引其检索效率非常高，索引的检索可以一次定位。

既然Hash索引的效率这么高，为什么都用Hash索引而还要使用B-Tree索引呢?

这是因为虽然Hash索引效率高，但是Hash索引本身由于其特殊性也带来了很多限制和弊端，主要有以下这些：

### 1. 原因一：

**Hash索引不能使用范围查询**

Hash索引仅仅能满足"=","IN"和"<=>"查询(注意<>和＜＝＞是不同的操作），不能使用范围查询，例如WHERE price > 100。

由于Hash索引比较的是进行Hash运算之后的Hash值，所以它只能用于等值的过滤，不能用于基于范围的过滤。

### 2. 原因二：

**Hash索引不能利用部分索引键查询。**

对于复合索引，Hash索引在计算Hash值的时候，是组合索引键合并后再一起计算Hash值，而不是单独计算Hash值。

所以通过复合索引的前面一个或几个索引键进行查询的时候，Hash索引也无法被利用。

### 3. 原因三：

**Hash索引在任何时候都不能避免表扫描。**

Hash索引是将索引键通过Hash运算之后，将 Hash运算结果的Hash值和所对应的行指针信息存放于一个Hash表中。

由于不同索引键存在相同Hash值，所以无法从Hash索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。


## 平衡二叉树索引

平衡二叉树的结构特点：

![mysql_avl_tree](https://luckylsx.github.io/images/mysql/mysql_avl_tree.png)

又称 AVL树。它除了具备二叉查找树的基本特征之外，还具有一个非常重要的特点：它的左子树和右子树都是平衡二叉树。

且左子树和右子树的深度之差的绝对值（平衡因子 ）不超过1。也就是说AVL树每个节点的平衡因子只可能是-1、0和1（左子树高度减去右子树高度）。

### 被淘汰的原因:

- 树的高度过高，高度越高，查找速度越慢
- 他支持范围查找，但是他需要在进行回旋查找

比如我要找到大于5的数据

第一步我先定位到5，然后在树上按照二叉树规则去回旋查找大于5其他数据6、7、8、9、10。。。

如果大于5的数据很多，那速度是很慢的。


## B树索引

![mysql_b_tree](https://luckylsx.github.io/images/mysql/mysql_b_tree.png)

大家可以看到B树和二叉树最大的区别在于：它一个节点可以存储两个值，这就意味着它的树高度，比二叉树的高度更低，它的查询速度就更快。这是他的优点

那为什么最终还是不用它呢，还是因为他在范围查找的时候，存在回旋查询的问题。同样order by排序的时候效率也很低，因为要把树上的数据手动排序一遍。

## 终极大佬：B+树:

![mysql_b_plus_tree](https://luckylsx.github.io/images/mysql/mysql_b_plus_tree.png)

它是B数的升级版，B+树相比B树，新增叶子节点与非叶子节点关系。

叶子节点中包含了key和value，key存储的是1-10这些数字，value存储的是数据存储地址，非叶子节点中只是包含了key，不包含value。

所有相邻的叶子节点包含非叶子节点，使用链表进行结合，有一定顺序排序，从而范围查询效率非常高

### 比如我们要查找大于5的数据：

- 首先我们定位到5的位置
- 然后直接将5后面的数据全部拿出来即可，因为这是有序链表，已经排好序了

我们在order by排序的时候为什么要使用索引进行排序，原因就在这。